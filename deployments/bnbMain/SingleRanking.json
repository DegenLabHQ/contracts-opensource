{
  "address": "0xAeDeA23af3Bf47EfADFB0d435bDe6c621078e11F",
  "abi": [],
  "transactionHash": "0x534a0675944305372f48759f56c55488d516ac6c323cfed6312816c8aa14b15c",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x93246E7F1618d7016A569a5F3E7B161DAb078d2d",
    "contractAddress": null,
    "transactionIndex": 192,
    "gasUsed": "807669",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x619bff9553653e7caa1f6349b3b1092387a08f9b7c9e3dc403afc71776dc4b63",
    "transactionHash": "0x534a0675944305372f48759f56c55488d516ac6c323cfed6312816c8aa14b15c",
    "logs": [],
    "blockNumber": 27539977,
    "cumulativeGasUsed": "18141278",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "692c4046effa55b26569080510ee00f4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/lib/SingleRanking.sol\":\"SingleRanking\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363832303734323531373938\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[],\"viaIR\":true},\"sources\":{\"src/lib/FastArray.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n// A simple array that supports insert and removal.\\n// The values are assumed to be unique and the library is meant to be lightweight.\\n// So when calling insert or remove, the caller is responsible to know whether a value already exists in the array or not.\\nlibrary FastArray {\\n    struct Data {\\n        mapping(uint256 => uint256) array;\\n        mapping(uint256 => uint256) indexMap;\\n        uint256 length;\\n    }\\n\\n    /**\\n     * @notice please confirm no eq item exist before insert\\n     */\\n    function insert(Data storage _fastArray, uint256 _value) public {\\n        _fastArray.array[_fastArray.length] = _value;\\n        _fastArray.indexMap[_value] = _fastArray.length;\\n        _fastArray.length += 1;\\n    }\\n\\n    /**\\n     * @dev remove item from array,but not keep rest item sort\\n     * @notice Please confirm array is not empty && item is exist && index not out of bounds\\n     */\\n    function remove(Data storage _fastArray, uint256 _value) public {\\n        uint256 index = _fastArray.indexMap[_value];\\n\\n        uint256 oldIndex = _fastArray.length - 1;\\n\\n        _fastArray.array[index] = _fastArray.array[oldIndex];\\n        delete _fastArray.indexMap[_value];\\n        delete _fastArray.array[oldIndex];\\n\\n        _fastArray.length = oldIndex;\\n    }\\n\\n    /**\\n     * @dev remove item and keep rest item in sort\\n     * @notice Please confirm array is not empty && item is exist && index not out of bounds\\n     */\\n    function removeKeepSort(Data storage _fastArray, uint256 _value) public {\\n        uint256 index = _fastArray.indexMap[_value];\\n\\n        uint256 tempLastItem = _fastArray.array[_fastArray.length - 1];\\n\\n        for (uint256 i = index; i < _fastArray.length - 1; i++) {\\n            _fastArray.indexMap[_fastArray.array[i + 1]] = i;\\n            _fastArray.array[i] = _fastArray.array[i + 1];\\n        }\\n\\n        delete _fastArray.indexMap[tempLastItem];\\n        delete _fastArray.array[_fastArray.length - 1];\\n        _fastArray.length -= 1;\\n    }\\n\\n    /**\\n     * @notice PLease confirm index is not out of bounds\\n     */\\n    function get(\\n        Data storage _fastArray,\\n        uint256 _index\\n    ) public view returns (uint256) {\\n        return _fastArray.array[_index];\\n    }\\n\\n    function length(Data storage _fastArray) public view returns (uint256) {\\n        return _fastArray.length;\\n    }\\n\\n    function contains(\\n        Data storage _fastArray,\\n        uint256 _value\\n    ) public view returns (bool) {\\n        return _fastArray.indexMap[_value] != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xfd8206ad787bf6c00652d6b0484b49bc4441a40b128f069a4962f3e5e2a67117\",\"license\":\"UNLICENSED\"},\"src/lib/RankingRedBlackTree.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// A red-black tree that holds a \\\"count\\\" variable next to the value in the tree.\\n// This library is used to resolve which values should be skipped to respect the _offset when querying from the rank library.\\n// The focal function is \\\"lastByOffset\\\" which starts from the largest value in the tree and traverses backwards to find the\\n// first value that is included in the offset specified and returns it.\\n// The nodes are accessed by a key and other properties can be queried using the key.\\n// This library is a modification of BokkyPooBah's Red-Black Tree Library which has a MIT licence.\\n// Following is the original description and the license:\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's Red-Black Tree Library v1.0-pre-release-a\\n//\\n// A Solidity Red-Black Tree binary search library to store and access a sorted\\n// list of unsigned integer data. The Red-Black algorithm rebalances the binary\\n// search tree, resulting in O(log n) insert, remove and search time (and ~gas)\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2020. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n// Here is the license attached to this library:\\n// ----------------------------------------------------------------------------\\n// MIT License\\n//\\n// Copyright (c) 2018 The Officious BokkyPooBah\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n// ----------------------------------------------------------------------------\\nlibrary RankingRedBlackTree {\\n    struct Node {\\n        uint id;\\n        uint value;\\n        uint count;\\n        uint parent;\\n        uint left;\\n        uint right;\\n        bool red;\\n    }\\n\\n    struct Tree {\\n        uint root;\\n        mapping(uint => Node) nodes;\\n        uint counter;\\n    }\\n\\n    uint private constant EMPTY = 0;\\n\\n    function first(Tree storage self) public view returns (uint _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].left != EMPTY) {\\n                _key = self.nodes[_key].left;\\n            }\\n        }\\n    }\\n\\n    function last(Tree storage self) public view returns (uint _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].right != EMPTY) {\\n                _key = self.nodes[_key].right;\\n            }\\n        }\\n    }\\n\\n    function lastByOffset(\\n        Tree storage self,\\n        uint _offset\\n    ) public view returns (uint, uint) {\\n        uint key = last(self);\\n\\n        while (key != EMPTY && _offset > self.nodes[key].count) {\\n            unchecked {\\n                _offset -= self.nodes[key].count;\\n            }\\n            key = prev(self, key);\\n        }\\n\\n        return (key, _offset);\\n    }\\n\\n    function next(\\n        Tree storage self,\\n        uint target\\n    ) public view returns (uint cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].right != EMPTY) {\\n            cursor = treeMinimum(self, self.nodes[target].right);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].right) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function prev(\\n        Tree storage self,\\n        uint target\\n    ) public view returns (uint cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].left != EMPTY) {\\n            cursor = treeMaximum(self, self.nodes[target].left);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].left) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function find(Tree storage self, uint _value) public view returns (uint) {\\n        uint probe = self.root;\\n        while (probe != EMPTY) {\\n            if (_value == self.nodes[probe].value) {\\n                return probe;\\n            }\\n            if (_value < self.nodes[probe].value) {\\n                probe = self.nodes[probe].left;\\n            } else {\\n                probe = self.nodes[probe].right;\\n            }\\n        }\\n        return EMPTY;\\n    }\\n\\n    function value(Tree storage self, uint _key) public view returns (uint) {\\n        return self.nodes[_key].value;\\n    }\\n\\n    function addToCount(Tree storage self, uint _value, uint amount) public {\\n        self.nodes[find(self, _value)].count += amount;\\n    }\\n\\n    function minusFromCount(\\n        Tree storage self,\\n        uint _value,\\n        uint amount\\n    ) public {\\n        self.nodes[find(self, _value)].count -= amount;\\n    }\\n\\n    function insert(Tree storage self, uint _value) public returns (uint) {\\n        uint cursor = EMPTY;\\n        uint probe = self.root;\\n        while (probe != EMPTY) {\\n            cursor = probe;\\n            if (_value < self.nodes[probe].value) {\\n                probe = self.nodes[probe].left;\\n            } else {\\n                probe = self.nodes[probe].right;\\n            }\\n        }\\n        self.counter += 1;\\n        self.nodes[self.counter] = Node({\\n            id: self.counter,\\n            value: _value,\\n            count: 1,\\n            parent: cursor,\\n            left: EMPTY,\\n            right: EMPTY,\\n            red: true\\n        });\\n        if (cursor == EMPTY) {\\n            self.root = self.counter;\\n        } else if (_value < self.nodes[cursor].value) {\\n            self.nodes[cursor].left = self.counter;\\n        } else {\\n            self.nodes[cursor].right = self.counter;\\n        }\\n        insertFixup(self, self.counter);\\n        return self.counter;\\n    }\\n\\n    function remove(Tree storage self, uint _value) public {\\n        uint key = find(self, _value);\\n        uint probe;\\n        uint cursor; // TODO\\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\\n            cursor = key;\\n        } else {\\n            cursor = self.nodes[key].right;\\n            while (self.nodes[cursor].left != EMPTY) {\\n                cursor = self.nodes[cursor].left;\\n            }\\n        }\\n        if (self.nodes[cursor].left != EMPTY) {\\n            probe = self.nodes[cursor].left;\\n        } else {\\n            probe = self.nodes[cursor].right;\\n        }\\n        uint yParent = self.nodes[cursor].parent;\\n        self.nodes[probe].parent = yParent;\\n        if (yParent != EMPTY) {\\n            if (cursor == self.nodes[yParent].left) {\\n                self.nodes[yParent].left = probe;\\n            } else {\\n                self.nodes[yParent].right = probe;\\n            }\\n        } else {\\n            self.root = probe;\\n        }\\n        bool doFixup = !self.nodes[cursor].red;\\n        if (cursor != key) {\\n            replaceParent(self, cursor, key);\\n            self.nodes[cursor].left = self.nodes[key].left;\\n            self.nodes[self.nodes[cursor].left].parent = cursor;\\n            self.nodes[cursor].right = self.nodes[key].right;\\n            self.nodes[self.nodes[cursor].right].parent = cursor;\\n            self.nodes[cursor].red = self.nodes[key].red;\\n            (cursor, key) = (key, cursor);\\n        }\\n        if (doFixup) {\\n            removeFixup(self, probe);\\n        }\\n        delete self.nodes[cursor];\\n    }\\n\\n    function removeWithKey(Tree storage self, uint key) public {\\n        uint probe;\\n        uint cursor; // TODO\\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\\n            cursor = key;\\n        } else {\\n            cursor = self.nodes[key].right;\\n            while (self.nodes[cursor].left != EMPTY) {\\n                cursor = self.nodes[cursor].left;\\n            }\\n        }\\n        if (self.nodes[cursor].left != EMPTY) {\\n            probe = self.nodes[cursor].left;\\n        } else {\\n            probe = self.nodes[cursor].right;\\n        }\\n        uint yParent = self.nodes[cursor].parent;\\n        self.nodes[probe].parent = yParent;\\n        if (yParent != EMPTY) {\\n            if (cursor == self.nodes[yParent].left) {\\n                self.nodes[yParent].left = probe;\\n            } else {\\n                self.nodes[yParent].right = probe;\\n            }\\n        } else {\\n            self.root = probe;\\n        }\\n        bool doFixup = !self.nodes[cursor].red;\\n        if (cursor != key) {\\n            replaceParent(self, cursor, key);\\n            self.nodes[cursor].left = self.nodes[key].left;\\n            self.nodes[self.nodes[cursor].left].parent = cursor;\\n            self.nodes[cursor].right = self.nodes[key].right;\\n            self.nodes[self.nodes[cursor].right].parent = cursor;\\n            self.nodes[cursor].red = self.nodes[key].red;\\n            (cursor, key) = (key, cursor);\\n        }\\n        if (doFixup) {\\n            removeFixup(self, probe);\\n        }\\n        delete self.nodes[cursor];\\n    }\\n\\n    function treeMinimum(\\n        Tree storage self,\\n        uint key\\n    ) private view returns (uint) {\\n        while (self.nodes[key].left != EMPTY) {\\n            key = self.nodes[key].left;\\n        }\\n        return key;\\n    }\\n\\n    function treeMaximum(\\n        Tree storage self,\\n        uint key\\n    ) private view returns (uint) {\\n        while (self.nodes[key].right != EMPTY) {\\n            key = self.nodes[key].right;\\n        }\\n        return key;\\n    }\\n\\n    function rotateLeft(Tree storage self, uint key) private {\\n        uint cursor = self.nodes[key].right;\\n        uint keyParent = self.nodes[key].parent;\\n        uint cursorLeft = self.nodes[cursor].left;\\n        self.nodes[key].right = cursorLeft;\\n        if (cursorLeft != EMPTY) {\\n            self.nodes[cursorLeft].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].left) {\\n            self.nodes[keyParent].left = cursor;\\n        } else {\\n            self.nodes[keyParent].right = cursor;\\n        }\\n        self.nodes[cursor].left = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function rotateRight(Tree storage self, uint key) private {\\n        uint cursor = self.nodes[key].left;\\n        uint keyParent = self.nodes[key].parent;\\n        uint cursorRight = self.nodes[cursor].right;\\n        self.nodes[key].left = cursorRight;\\n        if (cursorRight != EMPTY) {\\n            self.nodes[cursorRight].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].right) {\\n            self.nodes[keyParent].right = cursor;\\n        } else {\\n            self.nodes[keyParent].left = cursor;\\n        }\\n        self.nodes[cursor].right = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function insertFixup(Tree storage self, uint key) private {\\n        uint cursor;\\n        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\\n            uint keyParent = self.nodes[key].parent;\\n            if (keyParent == self.nodes[self.nodes[keyParent].parent].left) {\\n                cursor = self.nodes[self.nodes[keyParent].parent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].right) {\\n                        key = keyParent;\\n                        rotateLeft(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    rotateRight(self, self.nodes[keyParent].parent);\\n                }\\n            } else {\\n                cursor = self.nodes[self.nodes[keyParent].parent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].left) {\\n                        key = keyParent;\\n                        rotateRight(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    rotateLeft(self, self.nodes[keyParent].parent);\\n                }\\n            }\\n        }\\n        self.nodes[self.root].red = false;\\n    }\\n\\n    function replaceParent(Tree storage self, uint a, uint b) private {\\n        uint bParent = self.nodes[b].parent;\\n        self.nodes[a].parent = bParent;\\n        if (bParent == EMPTY) {\\n            self.root = a;\\n        } else {\\n            if (b == self.nodes[bParent].left) {\\n                self.nodes[bParent].left = a;\\n            } else {\\n                self.nodes[bParent].right = a;\\n            }\\n        }\\n    }\\n\\n    function removeFixup(Tree storage self, uint key) private {\\n        uint cursor;\\n        while (key != self.root && !self.nodes[key].red) {\\n            uint keyParent = self.nodes[key].parent;\\n            if (key == self.nodes[keyParent].left) {\\n                cursor = self.nodes[keyParent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    rotateLeft(self, keyParent);\\n                    cursor = self.nodes[keyParent].right;\\n                }\\n                if (\\n                    !self.nodes[self.nodes[cursor].left].red &&\\n                    !self.nodes[self.nodes[cursor].right].red\\n                ) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].right].red) {\\n                        self.nodes[self.nodes[cursor].left].red = false;\\n                        self.nodes[cursor].red = true;\\n                        rotateRight(self, cursor);\\n                        cursor = self.nodes[keyParent].right;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].right].red = false;\\n                    rotateLeft(self, keyParent);\\n                    key = self.root;\\n                }\\n            } else {\\n                cursor = self.nodes[keyParent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    rotateRight(self, keyParent);\\n                    cursor = self.nodes[keyParent].left;\\n                }\\n                if (\\n                    !self.nodes[self.nodes[cursor].right].red &&\\n                    !self.nodes[self.nodes[cursor].left].red\\n                ) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].left].red) {\\n                        self.nodes[self.nodes[cursor].right].red = false;\\n                        self.nodes[cursor].red = true;\\n                        rotateLeft(self, cursor);\\n                        cursor = self.nodes[keyParent].left;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].left].red = false;\\n                    rotateRight(self, keyParent);\\n                    key = self.root;\\n                }\\n            }\\n        }\\n        self.nodes[key].red = false;\\n    }\\n}\\n\",\"keccak256\":\"0xf57d5e1946cc4c76435318b6cfb39fbbd58249b84d0b966c38924940509a4404\",\"license\":\"MIT\"},\"src/lib/SingleRanking.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\nimport \\\"./FastArray.sol\\\";\\nimport \\\"./RankingRedBlackTree.sol\\\";\\n\\nlibrary SingleRanking {\\n    using FastArray for FastArray.Data;\\n    using RankingRedBlackTree for RankingRedBlackTree.Tree;\\n\\n    struct Data {\\n        RankingRedBlackTree.Tree tree;\\n        mapping(uint => FastArray.Data) keys;\\n        uint length;\\n    }\\n\\n    function add(Data storage _singleRanking, uint _key, uint _value) public {\\n        FastArray.Data storage keys = _singleRanking.keys[_value];\\n\\n        if (FastArray.length(keys) == 0) {\\n            _singleRanking.tree.insert(_value);\\n        } else {\\n            _singleRanking.tree.addToCount(_value, 1);\\n        }\\n\\n        _singleRanking.keys[_value].insert(_key);\\n\\n        _singleRanking.length += 1;\\n    }\\n\\n    function remove(\\n        Data storage _singleRanking,\\n        uint _key,\\n        uint _value\\n    ) public {\\n        FastArray.Data storage keys = _singleRanking.keys[_value];\\n\\n        if (FastArray.length(keys) > 0) {\\n            keys.remove(_key);\\n\\n            if (FastArray.length(keys) == 0) {\\n                _singleRanking.tree.remove(_value);\\n            } else {\\n                _singleRanking.tree.minusFromCount(_value, 1);\\n            }\\n        }\\n        // if FastArray.length(keys) is zero, it means logic error and should revert\\n        // but no revert here to reduce gas. use remove with caution\\n\\n        _singleRanking.length -= 1;\\n    }\\n\\n    function length(Data storage _singleRanking) public view returns (uint) {\\n        return _singleRanking.length;\\n    }\\n\\n    function get(\\n        Data storage _singleRanking,\\n        uint _offset,\\n        uint _count\\n    ) public view returns (uint[] memory) {\\n        require(_count > 0 && _count <= 100, \\\"Count must be between 0 and 100\\\");\\n\\n        uint[] memory result = new uint[](_count);\\n        uint size = 0;\\n        uint id;\\n        (id, _offset) = _singleRanking.tree.lastByOffset(_offset);\\n\\n        while (id != 0) {\\n            uint value = _singleRanking.tree.value(id);\\n            FastArray.Data storage keys = _singleRanking.keys[value];\\n\\n            if (_offset >= FastArray.length(keys)) {\\n                unchecked {\\n                    _offset -= FastArray.length(keys);\\n                }\\n            } else if (FastArray.length(keys) < _offset + _count) {\\n                uint index;\\n                unchecked {\\n                    index = FastArray.length(keys) - 1;\\n                }\\n                while (index >= _offset) {\\n                    uint key = keys.get(index);\\n\\n                    unchecked {\\n                        result[size] = key;\\n                        size += 1;\\n                    }\\n                    if (index == 0) {\\n                        break;\\n                    }\\n\\n                    unchecked {\\n                        index -= 1;\\n                    }\\n                }\\n\\n                unchecked {\\n                    _count -= FastArray.length(keys) - _offset;\\n                    _offset = 0;\\n                }\\n            } else {\\n                uint index;\\n                unchecked {\\n                    index = _offset + _count - 1;\\n                }\\n                while (index >= _offset) {\\n                    uint key = keys.get(index);\\n\\n                    result[size] = key;\\n                    unchecked {\\n                        size += 1;\\n                    }\\n\\n                    if (index == 0) {\\n                        break;\\n                    }\\n\\n                    unchecked {\\n                        index -= 1;\\n                    }\\n                }\\n\\n                break;\\n            }\\n\\n            id = _singleRanking.tree.prev(id);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getNthValue(\\n        Data storage _singleRanking,\\n        uint n\\n    ) public view returns (uint) {\\n        (uint256 id, ) = _singleRanking.tree.lastByOffset(n);\\n        uint value = _singleRanking.tree.value(id);\\n        return value;\\n    }\\n}\\n\",\"keccak256\":\"0xd8518b71301eebcbf2978c23df6c081532aaf4d8fe4e6679d05896a63c694cca\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001c57610d9b90816100228239308160080152f35b600080fdfe608080604052307f00000000000000000000000000000000000000000000000000000000000000001490600436101561003757600080fd5b600091823560e01c9182634d63fffd146106495750816352508d0e146104485781639f36d304146101b857508063b102d5fa1461019b5763d7b042ca1461007d57600080fd5b6040366003190112610198576004359073da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b969160405190630cd87de760e21b82528060048301526024356024830152604082604481875af491821561018d5790602092918492610158575b506044906040519586938492630ff567d560e11b8452600484015260248301525af490811561014c5790610115575b602090604051908152f35b506020813d8211610144575b8161012e60209383610ceb565b8101031261013f576020905161010a565b600080fd5b3d9150610121565b604051903d90823e3d90fd5b604491925061017e9060403d604011610186575b6101768183610ceb565b810190610d25565b5091906100db565b503d61016c565b6040513d85823e3d90fd5b80fd5b506020366003190112610198576020600480350154604051908152f35b905061019857806101c836610ca8565b808452600383016020908152604080862090516305f739f960e21b80825260048201839052602497957366d0E588E25Fb3bD1596C6b5729F1dadb177b81d93919285818b81885af490811561043d57889161040c575b50610254575b50505050505050600401805491600019830192831161024257505580f35b634e487b7160e01b8452601160045283fd5b833b15610408576040519063f9ff0d8560e01b8252826004830152898201528681604481875af49283156103fd57878a9287956103dd575b50506040519485938492835260048301525af49182156103d25784926103a1575b50506103335773da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b9690813b156103245782906044604051809481936315ed3cc160e01b8352886004840152898301525af4801561032857610310575b50506004905b905082388080808080610224565b61031990610cc2565b6103245782386102fc565b8280fd5b6040513d84823e3d90fd5b73da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b9690813b1561032457829060646040518094819363f263aa7760e01b835288600484015289830152600160448301525af480156103285761038d575b5050600490610302565b61039690610cc2565b610324578238610383565b8194508092503d83116103cb575b6103b98183610ceb565b8101031261013f5784915138806102ad565b503d6103af565b6040513d86823e3d90fd5b9092506103eb919450610cc2565b6103f957878492873861028c565b8580fd5b6040513d89823e3d90fd5b8680fd5b809850868092503d8311610436575b6104258183610ceb565b8101031261013f578996513861021e565b503d61041b565b6040513d8a823e3d90fd5b90506101985761045736610ca8565b929190600382019084845260209180835260408520927366d0E588E25Fb3bD1596C6b5729F1dadb177b81d93604051906305f739f960e21b825260048201528181602481885af49081156103fd57879161061c575b506105a95785966040969596516306ae5c7960e51b8152876004820152816024820152828160448173da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b965af480156103fd5761057b575b505b8552526040832090823b156105775760448492604051948593849263f715530760e01b8452600484015260248301525af480156103285761055f575b50506004018054906001820180921161054b575580f35b634e487b7160e01b83526011600452602483fd5b61056890610cc2565b610573578138610534565b5080fd5b8380fd5b82809297503d83116105a2575b6105928183610ceb565b8101031261013f578694386104f6565b503d610588565b73da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b9696873b156104085786606498604051998a809263060c8d6760e31b82528a6004830152856024830152600160448301525af480156103fd57610606575b8697509594956104f8565b9495909661061390610cc2565b949386906105fb565b90508181813d8311610642575b6106338183610ceb565b810103126104085751386104ac565b503d610629565b839061065436610ca8565b9290839184151580610c9d575b15610c5b575061067084610d0e565b9361067e6040519586610ceb565b80855261068d601f1991610d0e565b01366020860137849060405190630cd87de760e21b8252846004830152602482015260408160448173da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b965af48015610c505786918791610c2f575b50815b61072d575b505050505090604051918291602083016020845282518091526020604085019301915b818110610714575050500390f35b8251845285945060209384019390920191600101610706565b604051630ff567d560e11b815285600482015282602482015260208160448173da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b965af490811561043d578891610bfd575b5087526003850160205260408720906040516305f739f960e21b81528260048201526020816024817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af4908115610a96578991610bcb575b5081106108bd57604051916305f739f960e21b835260048301526020826024817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af491821561043d578892610885575b5003905b60405190631c72755760e01b8252856004830152602482015260208160448173da2D74f197c0E25E0D5c6127dbE66DFb9e9B9b965af49081156103fd578791610853575b5090816106de565b90506020813d60201161087d575b8161086e60209383610ceb565b8101031261040857518761084b565b3d9150610861565b9091506020813d6020116108b5575b816108a160209383610ceb565b810103126108b157519088610803565b8780fd5b3d9150610894565b906040949294516305f739f960e21b81528160048201526020816024817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af4908115610a96578991610b99575b508383018311610b85578284011115610ad3576040516305f739f960e21b8152600481018290526020816024817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af4908115610a96578991610aa1575b50600019015b828110156109dd575b50604051906305f739f960e21b825260048201526020816024817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af490811561043d5788916109ab575b50039003918590610807565b90506020813d6020116109d5575b816109c660209383610ceb565b810103126108b157518861099f565b3d91506109b9565b909192936040989798519063c9c3102d60e01b82528360048301528260248301526020826044817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af48015610a96578990610a5d575b60019250610a36828c610d3b565b5201908015610a5057969796909392919060001901610957565b9796979392919093610960565b50906020813d602011610a8e575b81610a7860209383610ceb565b81010312610a8a579060019151610a28565b8880fd5b3d9150610a6b565b6040513d8b823e3d90fd5b90506020813d602011610acb575b81610abc60209383610ceb565b81010312610a8a575189610951565b3d9150610aaf565b6000199550909350919083018401905b8382106106e3576040519063c9c3102d60e01b82528360048301528260248301526020826044817366d0E588E25Fb3bD1596C6b5729F1dadb177b81d5af4801561043d578890610b52575b60019250610b3c8289610d3b565b5201908015610b4d57840190610ae3565b6106e3565b506020823d602011610b7d575b81610b6c60209383610ceb565b810103126108b15760019151610b2e565b3d9150610b5f565b634e487b7160e01b89526011600452602489fd5b90506020813d602011610bc3575b81610bb460209383610ceb565b81010312610a8a5751896108ff565b3d9150610ba7565b90506020813d602011610bf5575b81610be660209383610ceb565b81010312610a8a5751896107be565b3d9150610bd9565b90506020813d602011610c27575b81610c1860209383610ceb565b810103126108b1575188610771565b3d9150610c0b565b9050610c4a915060403d604011610186576101768183610ceb565b876106db565b6040513d88823e3d90fd5b62461bcd60e51b815260206004820152601f60248201527f436f756e74206d757374206265206265747765656e203020616e6420313030006044820152606490fd5b506064851115610661565b606090600319011261013f57600435906024359060443590565b6001600160401b038111610cd557604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017610cd557604052565b6001600160401b038111610cd55760051b60200190565b919082604091031261013f576020825192015190565b8051821015610d4f5760209160051b010190565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220797dc9e11a51f5f97370b9094d61b248ec26a15d09f522f53dff2b1810805c1a64736f6c63430008110033",
  "deployedBytecode": "0x608080604052307f00000000000000000000000000000000000000000000000000000000000000001490600436101561003757600080fd5b600091823560e01c9182634d63fffd146106495750816352508d0e146104485781639f36d304146101b857508063b102d5fa1461019b5763d7b042ca1461007d57600080fd5b6040366003190112610198576004359073__$64be0ed8cff8e9c74167dfc40251eb2346$__9160405190630cd87de760e21b82528060048301526024356024830152604082604481875af491821561018d5790602092918492610158575b506044906040519586938492630ff567d560e11b8452600484015260248301525af490811561014c5790610115575b602090604051908152f35b506020813d8211610144575b8161012e60209383610ceb565b8101031261013f576020905161010a565b600080fd5b3d9150610121565b604051903d90823e3d90fd5b604491925061017e9060403d604011610186575b6101768183610ceb565b810190610d25565b5091906100db565b503d61016c565b6040513d85823e3d90fd5b80fd5b506020366003190112610198576020600480350154604051908152f35b905061019857806101c836610ca8565b808452600383016020908152604080862090516305f739f960e21b808252600482018390526024979573__$f445361e8b50888b0b8cee3fd4db50a783$__93919285818b81885af490811561043d57889161040c575b50610254575b50505050505050600401805491600019830192831161024257505580f35b634e487b7160e01b8452601160045283fd5b833b15610408576040519063f9ff0d8560e01b8252826004830152898201528681604481875af49283156103fd57878a9287956103dd575b50506040519485938492835260048301525af49182156103d25784926103a1575b50506103335773__$64be0ed8cff8e9c74167dfc40251eb2346$__90813b156103245782906044604051809481936315ed3cc160e01b8352886004840152898301525af4801561032857610310575b50506004905b905082388080808080610224565b61031990610cc2565b6103245782386102fc565b8280fd5b6040513d84823e3d90fd5b73__$64be0ed8cff8e9c74167dfc40251eb2346$__90813b1561032457829060646040518094819363f263aa7760e01b835288600484015289830152600160448301525af480156103285761038d575b5050600490610302565b61039690610cc2565b610324578238610383565b8194508092503d83116103cb575b6103b98183610ceb565b8101031261013f5784915138806102ad565b503d6103af565b6040513d86823e3d90fd5b9092506103eb919450610cc2565b6103f957878492873861028c565b8580fd5b6040513d89823e3d90fd5b8680fd5b809850868092503d8311610436575b6104258183610ceb565b8101031261013f578996513861021e565b503d61041b565b6040513d8a823e3d90fd5b90506101985761045736610ca8565b9291906003820190848452602091808352604085209273__$f445361e8b50888b0b8cee3fd4db50a783$__93604051906305f739f960e21b825260048201528181602481885af49081156103fd57879161061c575b506105a95785966040969596516306ae5c7960e51b8152876004820152816024820152828160448173__$64be0ed8cff8e9c74167dfc40251eb2346$__5af480156103fd5761057b575b505b8552526040832090823b156105775760448492604051948593849263f715530760e01b8452600484015260248301525af480156103285761055f575b50506004018054906001820180921161054b575580f35b634e487b7160e01b83526011600452602483fd5b61056890610cc2565b610573578138610534565b5080fd5b8380fd5b82809297503d83116105a2575b6105928183610ceb565b8101031261013f578694386104f6565b503d610588565b73__$64be0ed8cff8e9c74167dfc40251eb2346$__96873b156104085786606498604051998a809263060c8d6760e31b82528a6004830152856024830152600160448301525af480156103fd57610606575b8697509594956104f8565b9495909661061390610cc2565b949386906105fb565b90508181813d8311610642575b6106338183610ceb565b810103126104085751386104ac565b503d610629565b839061065436610ca8565b9290839184151580610c9d575b15610c5b575061067084610d0e565b9361067e6040519586610ceb565b80855261068d601f1991610d0e565b01366020860137849060405190630cd87de760e21b8252846004830152602482015260408160448173__$64be0ed8cff8e9c74167dfc40251eb2346$__5af48015610c505786918791610c2f575b50815b61072d575b505050505090604051918291602083016020845282518091526020604085019301915b818110610714575050500390f35b8251845285945060209384019390920191600101610706565b604051630ff567d560e11b815285600482015282602482015260208160448173__$64be0ed8cff8e9c74167dfc40251eb2346$__5af490811561043d578891610bfd575b5087526003850160205260408720906040516305f739f960e21b815282600482015260208160248173__$f445361e8b50888b0b8cee3fd4db50a783$__5af4908115610a96578991610bcb575b5081106108bd57604051916305f739f960e21b8352600483015260208260248173__$f445361e8b50888b0b8cee3fd4db50a783$__5af491821561043d578892610885575b5003905b60405190631c72755760e01b8252856004830152602482015260208160448173__$64be0ed8cff8e9c74167dfc40251eb2346$__5af49081156103fd578791610853575b5090816106de565b90506020813d60201161087d575b8161086e60209383610ceb565b8101031261040857518761084b565b3d9150610861565b9091506020813d6020116108b5575b816108a160209383610ceb565b810103126108b157519088610803565b8780fd5b3d9150610894565b906040949294516305f739f960e21b815281600482015260208160248173__$f445361e8b50888b0b8cee3fd4db50a783$__5af4908115610a96578991610b99575b508383018311610b85578284011115610ad3576040516305f739f960e21b81526004810182905260208160248173__$f445361e8b50888b0b8cee3fd4db50a783$__5af4908115610a96578991610aa1575b50600019015b828110156109dd575b50604051906305f739f960e21b8252600482015260208160248173__$f445361e8b50888b0b8cee3fd4db50a783$__5af490811561043d5788916109ab575b50039003918590610807565b90506020813d6020116109d5575b816109c660209383610ceb565b810103126108b157518861099f565b3d91506109b9565b909192936040989798519063c9c3102d60e01b825283600483015282602483015260208260448173__$f445361e8b50888b0b8cee3fd4db50a783$__5af48015610a96578990610a5d575b60019250610a36828c610d3b565b5201908015610a5057969796909392919060001901610957565b9796979392919093610960565b50906020813d602011610a8e575b81610a7860209383610ceb565b81010312610a8a579060019151610a28565b8880fd5b3d9150610a6b565b6040513d8b823e3d90fd5b90506020813d602011610acb575b81610abc60209383610ceb565b81010312610a8a575189610951565b3d9150610aaf565b6000199550909350919083018401905b8382106106e3576040519063c9c3102d60e01b825283600483015282602483015260208260448173__$f445361e8b50888b0b8cee3fd4db50a783$__5af4801561043d578890610b52575b60019250610b3c8289610d3b565b5201908015610b4d57840190610ae3565b6106e3565b506020823d602011610b7d575b81610b6c60209383610ceb565b810103126108b15760019151610b2e565b3d9150610b5f565b634e487b7160e01b89526011600452602489fd5b90506020813d602011610bc3575b81610bb460209383610ceb565b81010312610a8a5751896108ff565b3d9150610ba7565b90506020813d602011610bf5575b81610be660209383610ceb565b81010312610a8a5751896107be565b3d9150610bd9565b90506020813d602011610c27575b81610c1860209383610ceb565b810103126108b1575188610771565b3d9150610c0b565b9050610c4a915060403d604011610186576101768183610ceb565b876106db565b6040513d88823e3d90fd5b62461bcd60e51b815260206004820152601f60248201527f436f756e74206d757374206265206265747765656e203020616e6420313030006044820152606490fd5b506064851115610661565b606090600319011261013f57600435906024359060443590565b6001600160401b038111610cd557604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017610cd557604052565b6001600160401b038111610cd55760051b60200190565b919082604091031261013f576020825192015190565b8051821015610d4f5760209160051b010190565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220797dc9e11a51f5f97370b9094d61b248ec26a15d09f522f53dff2b1810805c1a64736f6c63430008110033",
  "libraries": {
    "FastArray": "0x66d0E588E25Fb3bD1596C6b5729F1dadb177b81d",
    "RankingRedBlackTree": "0xda2D74f197c0E25E0D5c6127dbE66DFb9e9B9b96"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}